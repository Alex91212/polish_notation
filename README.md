# polish_notation

== Quest received. Develop an src/graph.c program in C for creating graphs of functions defined by arbitrary expressions. To calculate the values ​​of expressions, use Dijkstra's algorithm for translating expressions into Polish notation. The program is assembled using a Makefile. The name of the build stage is all. The executable file must be stored at the root in the build folder named graph. Expressions containing any errors are considered incorrect, including unbalanced or empty brackets, as well as their incorrect nesting, the presence of invalid characters, functions or operators, and any deviations from the rules for constructing mathematical expressions. If the expression cannot be converted to a correct mathematical form for plotting, output n/a. ==


Краткие пояснения к функциям.


Функция split_totoken:
Получаем на вход строку - (2 + 3) * sin( x )
1. Логический блок - счтитаем количество токенов как колчиство пробелов + 1. Делаю так, чтобы не добавлять динамически память - ее можно потерять :)

2. Иду по строке данной на вход и start_of_token ставлю на начало токена и пока итерируюсь пока не встречу пробел (" ") тогда присваиваю end_of_token конец. Затем копирую эту строку в ответ (массив char** result) - можно было сделать при помощи функции strcpu.
Возвращаем массив строк - ['(', '2', '+', '3', ')', '*', 'sin', '(', 'x', ')']

Функция conver_to_polsk_not:
Получаем на вход массив строк - ['(', '2', '+', '3', ')', '*', 'sin', '(', 'x', ')']

1. Инициализируем стек - он нам нужен всего один (на него я выделяю места с запасом, используя длину массива токенов, который нам дали на вход - в выходной строке у нас будет меньше символов, потому что у нас точно не будет скобок. Считаю, что это ничего страшного)
     Инициализируем выходной массив в котором будет лежать польская нотация

2. Начинаю идти по массиву токенов:

2.1 Обработка скобок - она немного отличается от других символов { 
Если это скобка "(", то просто кладу ее в стек (при этом не заношу ее в выходную строку)
Если это ")", то просто достаем все из стека до "(" при этом сами скобки в выходной польской нотации быть не должны, поэтому мы их удалем из стека. Тут важно то, как мы достаем и кладем в polsk_not (это массив массивов или же массив строк)
}
Как работает процесс добавления в polsk_not
1. Мы не просто так завели переменную size_of_polsk_not - она помнит сколько значений у нас уже в выходной строке польской нотации. 
2. При каждом добавлении мы выделяем память на подмассив 
3. Затем копируем в эту строку значение из стека top->num (понимаете ли вы почему мы к полю структуры обращаемся не через точку, а по стрелочке ?) при помощи функции strcpy
4. удаляем элемент из стека, который мы уже отправили в выходную строку, при помощи команды pop
6. увеличиваем size_of_polsk_not - чтобы при следующем добавлении добавилось туда куда надо
7. Где работаем со скобками проверяем, чтобы случайно не добавить скобку

2.2 Если это число  - кладем его в выходную строку, потому что с чилами нам делать ничего не надо

2.3 Если это х, то тоже кладем его в выходную строку - никакой отдельной обработки он не требует

2.4 Если это операция
1. Если стек путой, то независимо от приоритета операции, которую мы сейчас рассматриваем - кладем его в стек операций
2. Если у операции в стеке приоритет больше, чем у той, которая у нас в руках (mass_token[i]), то добавляем в выходную строку операции из стека, у которых приоритет операций больше нашей в руках, а нашу кладем в стек
3. Если у операции больший приоритет, то добавляем ее в выходную строку - это значит если у нас там был +, а сейчас в руках (mass_token[i]) умножение, то мы просто кладем умножение перед +, почему так - чуть позже.

Вот то о чем обещал позже - мы делаем так, чтобы когда у нас закончиться массив токенов мы просто положили все что осталось в нас в стеке (while (top != NULL)) в выходную строку (заодно очистив стек)

возвращаем мы соответственно массив строк - 2 3 + x sin *



Далее описание алгоритма Дейкстры (сортировочной станции) от Deepseeka

Аналогия с железной дорогой
Представьте сортировочную железнодорожную станцию:

Вагоны (токены) едут по одному пути

У вас есть главный путь (выходная очередь)

И тупик/боковой путь (стек операторов)

Ваша задача - переставить вагоны в правильном порядке

Зачем два "пути" (стека)?
Главный путь (выходная очередь) - сюда попадают числа и переменные сразу, а операторы - только когда приходит их время

Тупик (стек операторов) - сюда временно отправляем операторы и скобки, чтобы дождаться их очереди

Суть алгоритма простыми словами
Идём по выражению слева направо и для каждого элемента:

Если это число или переменная (x) → сразу отправляем на главный путь

*Если это оператор (+, -, , / и т.д.) 

Смотрим: есть ли в тупике другие операторы?

Если да, проверяем их приоритет

Выгружаем из тупика ВСЕ операторы с БОЛЕЕ ВЫСОКИМ или РАВНЫМ приоритетом на главный путь

Только потом наш оператор отправляем в тупик

Если открывающая скобка ( → отправляем в тупик (как "начало новой группы")

Если закрывающая скобка ) →

Выгружаем из тупика ВСЁ до ближайшей открывающей скобки на главный путь

Саму скобку удаляем (она свою работу сделала)

Простой пример
Выражение: 2 + 3 * 4

Шаг 1: 2 → главный путь: [2]
Шаг 2: + → тупик: [+] (в тупике пусто, можно класть)
Шаг 3: 3 → главный путь: [2, 3]
Шаг 4: * → смотрим в тупике: там + с приоритетом 1

У * приоритет 2 (выше чем у +)

Значит, + остаётся в тупике, а * кладём рядом: тупик: [+, *]
Шаг 5: 4 → главный путь: [2, 3, 4]
Конец: выгружаем всё из тупика в обратном порядке: [2, 3, 4, *, +]

Результат: 2 3 4 * + - это и есть польская нотация!

